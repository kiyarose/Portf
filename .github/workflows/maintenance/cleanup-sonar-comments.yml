name: cleanup-sonar-comments

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  pull-requests: write
  issues: write

jobs:
  tidy:
    runs-on: ubuntu-latest
    steps:
      - name: Collapse outdated SonarQube bot comments
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pullNumber = context.issue.number;

            const issueComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: pullNumber,
              per_page: 100,
            });
            const sonarComments = issueComments
              .filter((comment) => {
                const body = comment.body?.trim() ?? '';
                return body.startsWith('## [![Quality Gate Passed]') ||
                  body.startsWith('## [![Quality Gate Failed]');
              })
              .map((comment) => ({
                id: comment.id,
                node_id: comment.node_id,
                created_at: comment.created_at,
              }));

            if (sonarComments.length <= 1) {
              core.info('Zero or one SonarQube comment found. Nothing to collapse.');
            } else {
              sonarComments.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              const [latest, ...older] = sonarComments;

              const minimize = async (nodeId) => {
                const mutation = `mutation($id: ID!) {
                  minimizeComment(input: {subjectId: $id, classifier: OUTDATED}) {
                    minimizedComment { isMinimized }
                  }
                }`;

                await github.graphql(mutation, { id: nodeId });
              };

              const unminimize = async (nodeId) => {
                const mutation = `mutation($id: ID!) {
                  unminimizeComment(input: {subjectId: $id}) {
                    unminimizedComment { isMinimized }
                  }
                }`;

                await github.graphql(mutation, { id: nodeId });
              };

              try {
                await unminimize(latest.node_id);
                core.info(`Ensured latest SonarQube comment (${latest.id}) is visible.`);
              } catch (error) {
                core.warning(`Failed to unminimize latest comment ${latest.id}: ${error.message}`);
              }

              for (const comment of older) {
                try {
                  await minimize(comment.node_id);
                  core.info(`Minimized SonarQube comment ${comment.id}.`);
                } catch (error) {
                  core.warning(`Failed to minimize comment ${comment.id}: ${error.message}`);
                }
              }
            }

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number: pullNumber,
              per_page: 100,
            });

            const lighthouseReviews = reviews
              .filter((review) => {
                const body = review.body?.trim() ?? '';
                return (
                  review.user?.login === 'github-actions[bot]' &&
                  body.startsWith('### Lighthouse CI Report')
                );
              })
              .map((review) => ({
                id: review.id,
                submitted_at: review.submitted_at ?? review.created_at ?? review.updated_at ?? new Date().toISOString(),
              }));

            if (lighthouseReviews.length <= 1) {
              core.info('Zero or one Lighthouse CI review found. Nothing to clean up.');
              return;
            }

            lighthouseReviews.sort((a, b) => new Date(b.submitted_at) - new Date(a.submitted_at));
            const [latestReview, ...staleReviews] = lighthouseReviews;
            core.info(`Keeping Lighthouse review ${latestReview.id} and deleting ${staleReviews.length} older review(s).`);

            for (const review of staleReviews) {
              try {
                await github.rest.pulls.deleteReview({
                  owner,
                  repo,
                  pull_number: pullNumber,
                  review_id: review.id,
                });
                core.info(`Deleted Lighthouse CI review ${review.id}.`);
              } catch (error) {
                core.warning(`Failed to delete Lighthouse review ${review.id}: ${error.message}`);
              }
            }
