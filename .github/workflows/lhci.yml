name: Lighthouse CI & Cleanup
permissions:
  contents: read
  pull-requests: write
  issues: write
on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  lighthouse-ci:
    name: Run Lighthouse CI
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm ci
      - run: npm run build
      - run: npx lhci autorun --outputDir=lhci-results || true # Don't fail yet
      - run: npx lhci assert --reporter json --reporter stdout > lhci-assert.json || true

      # Add a script to summarize the assertion failures
      - name: Summarize LHCI assertions
        id: summarize
        run: |
          node <<'EOF'
          const fs = require('fs');
          try {
            const data = JSON.parse(fs.readFileSync('lhci-assert.json', 'utf8'));
            if (!data.assertionResults || !data.assertionResults.length) {
              console.log('::set-output name=summary::No assertion results found.');
              process.exit(0);
            }
            let summary = '';
            data.assertionResults.forEach(r => {
              if (r.level === 'error') {
                summary += `âŒ **${r.auditId}** failed:\n`;
                summary += `- Expected: ${r.operator} ${r.expected}\n- Found: ${r.actual}\n- Path: ${r.url}\n\n`;
              }
            });
            if (!summary) summary = 'All assertions passed!';
            // Save to output
            fs.writeFileSync('lhci-summary.txt', summary);
            console.log(`::set-output name=summary::${summary}`);
          } catch (e) {
            console.error('Could not read LHCI assert json:', e);
            fs.writeFileSync('lhci-summary.txt', 'LHCI assertion parsing failed.');
            console.log('::set-output name=summary::LHCI assertion parsing failed.');
          }
          EOF

      # Add a review comment on the PR with the summary
      - name: Comment on PR with Lighthouse CI results
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('lhci-summary.txt', 'utf8');
            github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              event: 'COMMENT',
              body: `### Lighthouse CI Report\n\n${summary}\n\n[View detailed report](https://storage.googleapis.com/lighthouse-infrastructure.appspot.com/reports/1758932663189-43674.report.html)`
            });

  cleanup-comments:
    name: Clean up outdated comments
    runs-on: ubuntu-latest
    needs: lighthouse-ci
    if: always()
    steps:
      - name: Collapse outdated SonarQube and Lighthouse comments
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pullNumber = context.issue.number;

            // Clean up SonarQube comments
            const issueComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: pullNumber,
              per_page: 100,
            });
            const sonarComments = issueComments
              .filter((comment) => {
                const body = comment.body?.trim() ?? '';
                return body.startsWith('## [![Quality Gate Passed]') ||
                  body.startsWith('## [![Quality Gate Failed]');
              })
              .map((comment) => ({
                id: comment.id,
                node_id: comment.node_id,
                created_at: comment.created_at,
              }));

            if (sonarComments.length <= 1) {
              core.info('Zero or one SonarQube comment found. Nothing to collapse.');
            } else {
              sonarComments.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              const [latest, ...older] = sonarComments;

              const minimize = async (nodeId) => {
                const mutation = `mutation($id: ID!) {
                  minimizeComment(input: {subjectId: $id, classifier: OUTDATED}) {
                    minimizedComment { isMinimized }
                  }
                }`;

                await github.graphql(mutation, { id: nodeId });
              };

              const unminimize = async (nodeId) => {
                const mutation = `mutation($id: ID!) {
                  unminimizeComment(input: {subjectId: $id}) {
                    unminimizedComment { isMinimized }
                  }
                }`;

                await github.graphql(mutation, { id: nodeId });
              };

              try {
                await unminimize(latest.node_id);
                core.info(`Ensured latest SonarQube comment (${latest.id}) is visible.`);
              } catch (error) {
                core.warning(`Failed to unminimize latest comment ${latest.id}: ${error.message}`);
              }

              for (const comment of older) {
                try {
                  await minimize(comment.node_id);
                  core.info(`Minimized SonarQube comment ${comment.id}.`);
                } catch (error) {
                  core.warning(`Failed to minimize comment ${comment.id}: ${error.message}`);
                }
              }
            }

            // Clean up Lighthouse reviews
            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number: pullNumber,
              per_page: 100,
            });

            const lighthouseReviews = reviews
              .filter((review) => {
                const body = review.body?.trim() ?? '';
                return (
                  review.user?.login === 'github-actions[bot]' &&
                  body.startsWith('### Lighthouse CI Report')
                );
              })
              .map((review) => {
                const submittedAt = review.submitted_at ?? review.created_at ?? review.updated_at ?? new Date().toISOString();
                return {
                  id: review.id,
                  submitted_at: submittedAt,
                };
              });

            if (lighthouseReviews.length <= 1) {
              core.info('Zero or one Lighthouse CI review found. Nothing to clean up.');
              return;
            }

            lighthouseReviews.sort((a, b) => new Date(b.submitted_at) - new Date(a.submitted_at));
            const [latestReview, ...staleReviews] = lighthouseReviews;
            core.info(`Keeping Lighthouse review ${latestReview.id} and deleting ${staleReviews.length} older review(s).`);

            for (const review of staleReviews) {
              try {
                await github.rest.pulls.deleteReview({
                  owner,
                  repo,
                  pull_number: pullNumber,
                  review_id: review.id,
                });
                core.info(`Deleted Lighthouse CI review ${review.id}.`);
              } catch (error) {
                core.warning(`Failed to delete Lighthouse review ${review.id}: ${error.message}`);
              }
            }