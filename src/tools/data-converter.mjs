/* eslint-env node */
import fs from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import vm from 'node:vm'
import { createRequire } from 'node:module'
import { pathToFileURL } from 'node:url'
import ts from 'typescript'

const { console, URL, setTimeout, clearTimeout, setInterval, clearInterval } =
  globalThis
const global = globalThis

const VERSION = 1
const PLACEHOLDER_PREFIX = '__DATA_PLACEHOLDER__'
const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })
const printerSourceFile = ts.createSourceFile(
  'data-converter.ts',
  '',
  ts.ScriptTarget.Latest,
  false,
  ts.ScriptKind.TS
)

function printHelp () {
  console.log(
    'Usage: node src/tools/data-converter.mjs <command> [options] <files...>\n\nCommands:\n  to-json   Convert TypeScript data files to JSON with round-trip metadata\n  to-ts     Reconstruct TypeScript files from JSON generated by to-json\n\nOptions:\n  -o, --out <path>       Override output path (only when processing a single file)\n  --pick <export,...>    Restrict conversion to specific named exports\n  --overwrite            Allow overwriting existing output files\n  --quiet                Suppress success messages\n  -h, --help             Show this help message\n'
  )
}

function parseArgs (rawArgs) {
  const args = [...rawArgs]
  const options = {
    inputs: [],
    overwrite: false,
    quiet: false,
    out: null,
    picks: null
  }

  while (args.length > 0) {
    const arg = args.shift()
    switch (arg) {
      case '-h':
      case '--help':
        options.help = true
        return options
      case '--overwrite':
        options.overwrite = true
        break
      case '--quiet':
        options.quiet = true
        break
      case '-o':
      case '--out': {
        const value = args.shift()
        if (!value) {
          throw new Error(`Missing value after ${arg}`)
        }
        options.out = value
        break
      }
      case '--pick': {
        const value = args.shift()
        if (!value) {
          throw new Error(
            '--pick requires a comma-separated list of export names'
          )
        }
        const picks = value
          .split(',')
          .map((item) => item.trim())
          .filter(Boolean)
        if (picks.length === 0) {
          throw new Error('--pick must include at least one export name')
        }
        options.picks = new Set(picks)
        break
      }
      default:
        if (arg.startsWith('-')) {
          throw new Error(`Unknown option: ${arg}`)
        }
        options.inputs.push(arg)
    }
  }

  return options
}

function ensureSerializable (value, seen = new Set()) {
  if (value === null || value === undefined) {
    return true
  }

  const valueType = typeof value

  if (
    valueType === 'string' ||
    valueType === 'number' ||
    valueType === 'boolean'
  ) {
    return true
  }

  if (Array.isArray(value)) {
    if (seen.has(value)) {
      return false
    }
    seen.add(value)
    for (const item of value) {
      if (!ensureSerializable(item, seen)) {
        return false
      }
    }
    seen.delete(value)
    return true
  }

  if (valueType === 'object') {
    if (seen.has(value)) {
      return false
    }
    seen.add(value)
    for (const key of Object.keys(value)) {
      if (!ensureSerializable(value[key], seen)) {
        return false
      }
    }
    seen.delete(value)
    return true
  }

  return false
}

function unwrapLiteral (node) {
  if (ts.isAsExpression(node) || ts.isTypeAssertionExpression(node)) {
    return unwrapLiteral(node.expression)
  }
  if (ts.isParenthesizedExpression(node)) {
    return unwrapLiteral(node.expression)
  }
  return node
}

function computeBaseIndent (sourceText, valueStart) {
  const lineStart = sourceText.lastIndexOf('\n', valueStart - 1) + 1
  let indent = ''
  for (let index = lineStart; index < sourceText.length; index += 1) {
    const char = sourceText[index]
    if (char === ' ' || char === '\t') {
      indent += char
      continue
    }
    break
  }
  return indent
}

function collectExportEntries (sourceFile, sourceText, picks) {
  const entries = []
  const pickSet = picks ? new Set(picks) : null
  const seenNames = new Set()

  for (const statement of sourceFile.statements) {
    if (!ts.isVariableStatement(statement)) {
      continue
    }

    const hasExportModifier = statement.modifiers?.some(
      (modifier) => modifier.kind === ts.SyntaxKind.ExportKeyword
    )

    if (!hasExportModifier) {
      continue
    }

    for (const declaration of statement.declarationList.declarations) {
      if (!ts.isIdentifier(declaration.name)) {
        continue
      }

      const name = declaration.name.text
      if (pickSet && !pickSet.has(name)) {
        continue
      }

      if (!declaration.initializer) {
        continue
      }

      const literalNode = unwrapLiteral(declaration.initializer)
      if (
        !ts.isArrayLiteralExpression(literalNode) &&
        !ts.isObjectLiteralExpression(literalNode)
      ) {
        continue
      }

      const valueStart = literalNode.getStart(sourceFile)
      const valueEnd = literalNode.getEnd()

      if (seenNames.has(name)) {
        throw new Error(`Duplicate export named ${name}`)
      }

      const placeholder = `${PLACEHOLDER_PREFIX}${name}_${valueStart}_${valueEnd}__`
      const baseIndent = computeBaseIndent(sourceText, valueStart)

      entries.push({
        name,
        valueStart,
        valueEnd,
        placeholder,
        baseIndent
      })
      seenNames.add(name)
    }
  }

  if (pickSet) {
    for (const requested of pickSet) {
      if (!seenNames.has(requested)) {
        throw new Error(
          `Requested export \`${requested}\` was not found or is not convertible`
        )
      }
    }
  }

  return entries
}

function buildTemplate (sourceText, entries) {
  const sorted = [...entries].sort((a, b) => a.valueStart - b.valueStart)
  let cursor = 0
  let result = ''

  for (const entry of sorted) {
    result += sourceText.slice(cursor, entry.valueStart)
    result += entry.placeholder
    cursor = entry.valueEnd
  }

  result += sourceText.slice(cursor)
  return result
}

function evaluateModule (sourcePath, sourceText) {
  const transpiled = ts.transpileModule(sourceText, {
    compilerOptions: {
      module: ts.ModuleKind.CommonJS,
      target: ts.ScriptTarget.ES2020,
      esModuleInterop: true
    },
    fileName: sourcePath
  })

  const moduleExports = {}
  const moduleObject = { exports: moduleExports }
  const script = new vm.Script(transpiled.outputText, { filename: sourcePath })
  const require = createRequire(pathToFileURL(sourcePath))

  const context = vm.createContext({
    module: moduleObject,
    exports: moduleObject.exports,
    require,
    __filename: sourcePath,
    __dirname: path.dirname(sourcePath),
    console,
    process,
    global,
    setTimeout,
    clearTimeout,
    setInterval,
    clearInterval,
    URL
  })

  script.runInContext(context)
  return moduleObject.exports
}

function isIdentifierCandidate (text) {
  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(text)
}

function createLiteralFromValue (value) {
  if (value === null) {
    return ts.factory.createNull()
  }

  switch (typeof value) {
    case 'string':
      return ts.factory.createStringLiteral(value)
    case 'number':
      return Number.isFinite(value)
        ? ts.factory.createNumericLiteral(value)
        : ts.factory.createStringLiteral(String(value))
    case 'boolean':
      return value ? ts.factory.createTrue() : ts.factory.createFalse()
    case 'object': {
      if (Array.isArray(value)) {
        const elements = value.map((item) => createLiteralFromValue(item))
        return ts.factory.createArrayLiteralExpression(
          elements,
          elements.length > 0
        )
      }

      const entries = Object.entries(value).map(([key, item]) => {
        const nameNode = isIdentifierCandidate(key)
          ? ts.factory.createIdentifier(key)
          : ts.factory.createStringLiteral(key)

        return ts.factory.createPropertyAssignment(
          nameNode,
          createLiteralFromValue(item)
        )
      })

      return ts.factory.createObjectLiteralExpression(
        entries,
        entries.length > 0
      )
    }
    default:
      throw new Error(`Unsupported value type: ${typeof value}`)
  }
}

function formatValueForTs (value, baseIndent) {
  const literal = createLiteralFromValue(value)
  const printed = printer.printNode(
    ts.EmitHint.Expression,
    literal,
    printerSourceFile
  )
  const lines = printed.split('\n')

  if (lines.length === 1) {
    return lines[0]
  }

  const indentPrefix = baseIndent ?? ''
  const formatted = [lines[0]]

  for (let index = 1; index < lines.length; index += 1) {
    const line = lines[index]
    if (line.length === 0) {
      formatted.push(line)
      continue
    }

    const match = line.match(/^(\s*)(.*)$/)
    const [, leadingSpaces = '', rest = ''] = match ?? []
    const indentLevel =
      leadingSpaces.length > 0 ? Math.floor(leadingSpaces.length / 4) : 0
    const remainder = leadingSpaces.length - indentLevel * 4
    const adjustedIndent = `${indentPrefix}${'  '.repeat(indentLevel)}${remainder > 0 ? ' '.repeat(remainder) : ''}`
    formatted.push(`${adjustedIndent}${rest}`)
  }

  return formatted.join('\n')
}

function convertTsToJson (filePath, { out, overwrite, picks, quiet }) {
  const resolvedPath = path.resolve(filePath)
  if (!fs.existsSync(resolvedPath)) {
    throw new Error(`Source file not found: ${filePath}`)
  }

  const sourceText = fs.readFileSync(resolvedPath, 'utf8')
  const sourceFile = ts.createSourceFile(
    resolvedPath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    ts.ScriptKind.TS
  )

  const entries = collectExportEntries(sourceFile, sourceText, picks)

  if (entries.length === 0) {
    throw new Error(
      `No convertible exported arrays or objects were found in ${filePath}. Use --pick to select a specific export if needed.`
    )
  }

  const template = buildTemplate(sourceText, entries)
  const exportsObject = evaluateModule(resolvedPath, sourceText)

  const output = {
    __meta: {
      version: VERSION,
      template,
      source: path.relative(process.cwd(), resolvedPath),
      entries: entries.map((entry) => ({
        name: entry.name,
        placeholder: entry.placeholder,
        baseIndent: entry.baseIndent
      })),
      generatedAt: new Date().toISOString()
    }
  }

  for (const entry of entries) {
    if (!(entry.name in exportsObject)) {
      throw new Error(
        `Export \`${entry.name}\` could not be evaluated from ${filePath}. Ensure it is exported as a value.`
      )
    }

    const value = exportsObject[entry.name]
    if (!ensureSerializable(value)) {
      throw new Error(
        `Export \`${entry.name}\` contains non-serializable data. Only plain objects, arrays, and primitives are supported.`
      )
    }

    output[entry.name] = value
  }

  const defaultOutPath = path.join(
    path.dirname(resolvedPath),
    `${path.basename(resolvedPath, path.extname(resolvedPath))}.json`
  )
  const targetPath = out ? path.resolve(out) : defaultOutPath

  if (!overwrite && fs.existsSync(targetPath)) {
    throw new Error(
      `Refusing to overwrite existing file ${path.relative(process.cwd(), targetPath)}. Pass --overwrite to allow overwriting.`
    )
  }

  fs.writeFileSync(targetPath, `${JSON.stringify(output, null, 2)}\n`, 'utf8')

  if (!quiet) {
    console.log(
      `Converted ${path.relative(process.cwd(), resolvedPath)} -> ${path.relative(
        process.cwd(),
        targetPath
      )}`
    )
  }

  return targetPath
}

function convertJsonToTs (filePath, { out, overwrite, picks, quiet }) {
  const resolvedPath = path.resolve(filePath)
  if (!fs.existsSync(resolvedPath)) {
    throw new Error(`JSON file not found: ${filePath}`)
  }

  const parsed = JSON.parse(fs.readFileSync(resolvedPath, 'utf8'))

  if (!parsed.__meta || typeof parsed.__meta !== 'object') {
    throw new Error(
      'Missing __meta section. This JSON file was not generated by data-converter.mjs'
    )
  }

  if (parsed.__meta.version !== VERSION) {
    throw new Error(
      `Unsupported metadata version ${parsed.__meta.version}. Expected version ${VERSION}.`
    )
  }

  const { template, entries, source: originalSource } = parsed.__meta

  if (!template || !Array.isArray(entries)) {
    throw new Error('Malformed metadata: template or entries missing')
  }

  const pickSet = picks ? new Set(picks) : null
  let outputText = template

  for (const entry of entries) {
    if (!entry || !entry.name || !entry.placeholder) {
      throw new Error('Malformed metadata entry encountered')
    }

    if (pickSet && !pickSet.has(entry.name)) {
      continue
    }

    if (!(entry.name in parsed)) {
      throw new Error(`JSON data missing export \`${entry.name}\``)
    }

    const value = parsed[entry.name]
    const replacement = formatValueForTs(value, entry.baseIndent ?? '')

    if (!outputText.includes(entry.placeholder)) {
      throw new Error(
        `Placeholder for export \`${entry.name}\` was not found in metadata template. The JSON file may be corrupted.`
      )
    }

    outputText = outputText.replace(entry.placeholder, replacement)
  }

  const defaultOutPath = originalSource
    ? path.resolve(originalSource)
    : path.join(path.dirname(resolvedPath), 'restored.ts')

  const targetPath = out ? path.resolve(out) : defaultOutPath

  if (!overwrite && fs.existsSync(targetPath)) {
    throw new Error(
      `Refusing to overwrite existing file ${path.relative(process.cwd(), targetPath)}. Pass --overwrite to allow overwriting.`
    )
  }

  fs.writeFileSync(targetPath, outputText, 'utf8')

  if (!quiet) {
    console.log(
      `Converted ${path.relative(process.cwd(), resolvedPath)} -> ${path.relative(
        process.cwd(),
        targetPath
      )}`
    )
  }

  return targetPath
}

function main () {
  const [command, ...rest] = process.argv.slice(2)

  if (!command || command === '-h' || command === '--help') {
    printHelp()
    if (!command) {
      throw new Error('No command provided.')
    }
    return
  }

  const options = parseArgs(rest)

  if (options.help) {
    printHelp()
    return
  }

  if (options.inputs.length === 0) {
    printHelp()
    throw new Error('No input files provided.')
  }

  if (options.out && options.inputs.length > 1) {
    throw new Error(
      '--out can only be used when processing a single input file.'
    )
  }

  if (command === 'to-json') {
    for (const input of options.inputs) {
      convertTsToJson(input, options)
    }
    return
  }

  if (command === 'to-ts') {
    for (const input of options.inputs) {
      convertJsonToTs(input, options)
    }
    return
  }

  printHelp()
  throw new Error(`Unknown command: ${command}`)
}

main()
