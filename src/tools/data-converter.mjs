/* eslint-env node */
import fs from "node:fs";
import path from "node:path";
import process from "node:process";
import vm from "node:vm";
import { createRequire } from "node:module";
import { pathToFileURL } from "node:url";
import ts from "typescript";

const { console, URL, setTimeout, clearTimeout, setInterval, clearInterval } =
  globalThis;
const global = globalThis;

const VERSION = 1;
const PLACEHOLDER_PREFIX = "__DATA_PLACEHOLDER__";
const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
const printerSourceFile = ts.createSourceFile(
  "data-converter.ts",
  "",
  ts.ScriptTarget.Latest,
  false,
  ts.ScriptKind.TS,
);

function printHelp() {
  console.log(
    "Usage: node src/tools/data-converter.mjs <command> [options] <files...>\n\nCommands:\n  to-json   Convert TypeScript data files to JSON with round-trip metadata\n  to-ts     Reconstruct TypeScript files from JSON generated by to-json\n\nOptions:\n  -o, --out <path>       Override output path (only when processing a single file)\n  --pick <export,...>    Restrict conversion to specific named exports\n  --overwrite            Allow overwriting existing output files\n  --quiet                Suppress success messages\n  -h, --help             Show this help message\n",
  );
}

function parseArgs(rawArgs) {
  const args = [...rawArgs];
  const options = {
    inputs: [],
    overwrite: false,
    quiet: false,
    out: null,
    picks: null,
  };

  while (args.length > 0) {
    const arg = args.shift();
    switch (arg) {
      case "-h":
      case "--help":
        options.help = true;
        return options;
      case "--overwrite":
        options.overwrite = true;
        break;
      case "--quiet":
        options.quiet = true;
        break;
      case "-o":
      case "--out": {
        const value = args.shift();
        if (!value) {
          throw new Error(`Missing value after ${arg}`);
        }
        options.out = value;
        break;
      }
      case "--pick": {
        const value = args.shift();
        if (!value) {
          throw new Error(
            "--pick requires a comma-separated list of export names",
          );
        }
        const picks = value
          .split(",")
          .map((item) => item.trim())
          .filter(Boolean);
        if (picks.length === 0) {
          throw new Error("--pick must include at least one export name");
        }
        options.picks = new Set(picks);
        break;
      }
      default:
        if (arg.startsWith("-")) {
          throw new Error(`Unknown option: ${arg}`);
        }
        options.inputs.push(arg);
    }
  }

  return options;
}

function ensureSerializable(value, seen = new Set()) {
  if (value === null || value === undefined) {
    return true;
  }

  const valueType = typeof value;

  if (
    valueType === "string" ||
    valueType === "number" ||
    valueType === "boolean"
  ) {
    return true;
  }

  if (Array.isArray(value)) {
    if (seen.has(value)) {
      return false;
    }
    seen.add(value);
    for (const item of value) {
      if (!ensureSerializable(item, seen)) {
        return false;
      }
    }
    seen.delete(value);
    return true;
  }

  if (valueType === "object") {
    if (seen.has(value)) {
      return false;
    }
    seen.add(value);
    for (const key of Object.keys(value)) {
      if (!ensureSerializable(value[key], seen)) {
        return false;
      }
    }
    seen.delete(value);
    return true;
  }

  return false;
}

function unwrapLiteral(node) {
  if (ts.isAsExpression(node) || ts.isTypeAssertionExpression(node)) {
    return unwrapLiteral(node.expression);
  }
  if (ts.isParenthesizedExpression(node)) {
    return unwrapLiteral(node.expression);
  }
  return node;
}

function computeBaseIndent(sourceText, valueStart) {
  const lineStart = sourceText.lastIndexOf("\n", valueStart - 1) + 1;
  let indent = "";
  for (let index = lineStart; index < sourceText.length; index += 1) {
    const char = sourceText[index];
    if (char === " " || char === "\t") {
      indent += char;
      continue;
    }
    break;
  }
  return indent;
}

function collectExportEntries(sourceFile, sourceText, picks) {
  const entries = [];
  const pickSet = picks ? new Set(picks) : null;
  const seenNames = new Set();

  for (const statement of sourceFile.statements) {
    if (!ts.isVariableStatement(statement)) {
      continue;
    }

    const hasExportModifier = statement.modifiers?.some(
      (modifier) => modifier.kind === ts.SyntaxKind.ExportKeyword,
    );

    if (!hasExportModifier) {
      continue;
    }

    for (const declaration of statement.declarationList.declarations) {
      if (!ts.isIdentifier(declaration.name)) {
        continue;
      }

      const name = declaration.name.text;
      if (pickSet && !pickSet.has(name)) {
        continue;
      }

      if (!declaration.initializer) {
        continue;
      }

      const literalNode = unwrapLiteral(declaration.initializer);
      if (
        !ts.isArrayLiteralExpression(literalNode) &&
        !ts.isObjectLiteralExpression(literalNode)
      ) {
        continue;
      }

      const valueStart = literalNode.getStart(sourceFile);
      const valueEnd = literalNode.getEnd();

      if (seenNames.has(name)) {
        throw new Error(`Duplicate export named ${name}`);
      }

      const placeholder = `${PLACEHOLDER_PREFIX}${name}_${valueStart}_${valueEnd}__`;
      const baseIndent = computeBaseIndent(sourceText, valueStart);

      entries.push({
        name,
        valueStart,
        valueEnd,
        placeholder,
        baseIndent,
      });
      seenNames.add(name);
    }
  }

  if (pickSet) {
    for (const requested of pickSet) {
      if (!seenNames.has(requested)) {
        throw new Error(
          `Requested export \`${requested}\` was not found or is not convertible`,
        );
      }
    }
  }

  return entries;
}

function buildTemplate(sourceText, entries) {
  const sorted = [...entries].sort((a, b) => a.valueStart - b.valueStart);
  let cursor = 0;
  let result = "";

  for (const entry of sorted) {
    result += sourceText.slice(cursor, entry.valueStart);
    result += entry.placeholder;
    cursor = entry.valueEnd;
  }

  result += sourceText.slice(cursor);
  return result;
}

function evaluateModule(sourcePath, sourceText) {
  const transpiled = ts.transpileModule(sourceText, {
    compilerOptions: {
      module: ts.ModuleKind.CommonJS,
      target: ts.ScriptTarget.ES2020,
      esModuleInterop: true,
    },
    fileName: sourcePath,
  });

  const moduleExports = {};
  const moduleObject = { exports: moduleExports };
  const script = new vm.Script(transpiled.outputText, { filename: sourcePath });
  const require = createRequire(pathToFileURL(sourcePath));

  const context = vm.createContext({
    module: moduleObject,
    exports: moduleObject.exports,
    require,
    __filename: sourcePath,
    __dirname: path.dirname(sourcePath),
    console,
    process,
    global,
    setTimeout,
    clearTimeout,
    setInterval,
    clearInterval,
    URL,
  });

  script.runInContext(context);
  return moduleObject.exports;
}

function isIdentifierCandidate(text) {
  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(text);
}

function createLiteralFromValue(value) {
  if (value === null) {
    return ts.factory.createNull();
  }

  switch (typeof value) {
    case "string":
      return ts.factory.createStringLiteral(value);
    case "number":
      return Number.isFinite(value)
        ? ts.factory.createNumericLiteral(value)
        : ts.factory.createStringLiteral(String(value));
    case "boolean":
      return value ? ts.factory.createTrue() : ts.factory.createFalse();
    case "object": {
      if (Array.isArray(value)) {
        const elements = value.map((item) => createLiteralFromValue(item));
        return ts.factory.createArrayLiteralExpression(
          elements,
          elements.length > 0,
        );
      }

      const entries = Object.entries(value).map(([key, item]) => {
        const nameNode = isIdentifierCandidate(key)
          ? ts.factory.createIdentifier(key)
          : ts.factory.createStringLiteral(key);

        return ts.factory.createPropertyAssignment(
          nameNode,
          createLiteralFromValue(item),
        );
      });

      return ts.factory.createObjectLiteralExpression(
        entries,
        entries.length > 0,
      );
    }
    default:
      throw new Error(`Unsupported value type: ${typeof value}`);
  }
}

function formatValueForTs(value, baseIndent) {
  const literal = createLiteralFromValue(value);
  const printed = printer.printNode(
    ts.EmitHint.Expression,
    literal,
    printerSourceFile,
  );
  const lines = printed.split("\n");

  if (lines.length === 1) {
    return lines[0];
  }

  const indentPrefix = baseIndent ?? "";
  const formatted = [lines[0]];

  for (let index = 1; index < lines.length; index += 1) {
    const line = lines[index];
    if (line.length === 0) {
      formatted.push(line);
      continue;
    }

    const match = line.match(/^(\s*)(.*)$/);
    const [, leadingSpaces = "", rest = ""] = match ?? [];
    const indentLevel =
      leadingSpaces.length > 0 ? Math.floor(leadingSpaces.length / 4) : 0;
    const remainder = leadingSpaces.length - indentLevel * 4;
    const adjustedIndent = `${indentPrefix}${"  ".repeat(indentLevel)}${remainder > 0 ? " ".repeat(remainder) : ""}`;
    formatted.push(`${adjustedIndent}${rest}`);
  }

  return formatted.join("\n");
}

function convertTsToJson(filePath, { out, overwrite, picks, quiet }) {
  const resolvedPath = path.resolve(filePath);
  if (!fs.existsSync(resolvedPath)) {
    throw new Error(`Source file not found: ${filePath}`);
  }

  const sourceText = fs.readFileSync(resolvedPath, "utf8");
  const sourceFile = ts.createSourceFile(
    resolvedPath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    ts.ScriptKind.TS,
  );

  const entries = collectExportEntries(sourceFile, sourceText, picks);

  if (entries.length === 0) {
    throw new Error(
      `No convertible exported arrays or objects were found in ${filePath}. Use --pick to select a specific export if needed.`,
    );
  }

  const template = buildTemplate(sourceText, entries);
  const exportsObject = evaluateModule(resolvedPath, sourceText);

  const output = {
    __meta: {
      version: VERSION,
      template,
      source: path.relative(process.cwd(), resolvedPath),
      entries: entries.map((entry) => ({
        name: entry.name,
        placeholder: entry.placeholder,
        baseIndent: entry.baseIndent,
      })),
      generatedAt: new Date().toISOString(),
    },
  };

  for (const entry of entries) {
    if (!(entry.name in exportsObject)) {
      throw new Error(
        `Export \`${entry.name}\` could not be evaluated from ${filePath}. Ensure it is exported as a value.`,
      );
    }

    const value = exportsObject[entry.name];
    if (!ensureSerializable(value)) {
      throw new Error(
        `Export \`${entry.name}\` contains non-serializable data. Only plain objects, arrays, and primitives are supported.`,
      );
    }

    output[entry.name] = value;
  }

  const defaultOutPath = path.join(
    path.dirname(resolvedPath),
    `${path.basename(resolvedPath, path.extname(resolvedPath))}.json`,
  );
  const targetPath = out ? path.resolve(out) : defaultOutPath;

  if (!overwrite && fs.existsSync(targetPath)) {
    throw new Error(
      `Refusing to overwrite existing file ${path.relative(process.cwd(), targetPath)}. Pass --overwrite to allow overwriting.`,
    );
  }

  fs.writeFileSync(targetPath, `${JSON.stringify(output, null, 2)}\n`, "utf8");

  if (!quiet) {
    console.log(
      `Converted ${path.relative(process.cwd(), resolvedPath)} -> ${path.relative(
        process.cwd(),
        targetPath,
      )}`,
    );
  }

  return targetPath;
}

function convertJsonToTs(filePath, { out, overwrite, picks, quiet }) {
  const resolvedPath = path.resolve(filePath);
  if (!fs.existsSync(resolvedPath)) {
    throw new Error(`JSON file not found: ${filePath}`);
  }

  const parsed = JSON.parse(fs.readFileSync(resolvedPath, "utf8"));

  if (!parsed.__meta || typeof parsed.__meta !== "object") {
    throw new Error(
      "Missing __meta section. This JSON file was not generated by data-converter.mjs",
    );
  }

  if (parsed.__meta.version !== VERSION) {
    throw new Error(
      `Unsupported metadata version ${parsed.__meta.version}. Expected version ${VERSION}.`,
    );
  }

  const { template, entries, source: originalSource } = parsed.__meta;

  if (!template || !Array.isArray(entries)) {
    throw new Error("Malformed metadata: template or entries missing");
  }

  const pickSet = picks ? new Set(picks) : null;
  let outputText = template;

  for (const entry of entries) {
    if (!entry || !entry.name || !entry.placeholder) {
      throw new Error("Malformed metadata entry encountered");
    }

    if (pickSet && !pickSet.has(entry.name)) {
      continue;
    }

    if (!(entry.name in parsed)) {
      throw new Error(`JSON data missing export \`${entry.name}\``);
    }

    const value = parsed[entry.name];
    const replacement = formatValueForTs(value, entry.baseIndent ?? "");

    if (!outputText.includes(entry.placeholder)) {
      throw new Error(
        `Placeholder for export \`${entry.name}\` was not found in metadata template. The JSON file may be corrupted.`,
      );
    }

    outputText = outputText.replace(entry.placeholder, replacement);
  }

  const defaultOutPath = originalSource
    ? path.resolve(originalSource)
    : path.join(path.dirname(resolvedPath), "restored.ts");

  const targetPath = out ? path.resolve(out) : defaultOutPath;

  if (!overwrite && fs.existsSync(targetPath)) {
    throw new Error(
      `Refusing to overwrite existing file ${path.relative(process.cwd(), targetPath)}. Pass --overwrite to allow overwriting.`,
    );
  }

  fs.writeFileSync(targetPath, outputText, "utf8");

  if (!quiet) {
    console.log(
      `Converted ${path.relative(process.cwd(), resolvedPath)} -> ${path.relative(
        process.cwd(),
        targetPath,
      )}`,
    );
  }

  return targetPath;
}

function main() {
  const [command, ...rest] = process.argv.slice(2);

  if (!command || command === "-h" || command === "--help") {
    printHelp();
    if (!command) {
      throw new Error("No command provided.");
    }
    return;
  }

  const options = parseArgs(rest);

  if (options.help) {
    printHelp();
    return;
  }

  if (options.inputs.length === 0) {
    printHelp();
    throw new Error("No input files provided.");
  }

  if (options.out && options.inputs.length > 1) {
    throw new Error(
      "--out can only be used when processing a single input file.",
    );
  }

  if (command === "to-json") {
    for (const input of options.inputs) {
      convertTsToJson(input, options);
    }
    return;
  }

  if (command === "to-ts") {
    for (const input of options.inputs) {
      convertJsonToTs(input, options);
    }
    return;
  }

  printHelp();
  throw new Error(`Unknown command: ${command}`);
}

main();
